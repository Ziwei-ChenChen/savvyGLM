% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/savvy_glm.fit2.R
\name{savvy_glm.fit2}
\alias{savvy_glm.fit2}
\title{Generalized Linear Models Fitting with Slab and Shrinkage Estimators}
\usage{
savvy_glm.fit2(x, y, weights = rep(1, nobs),
                        model_class = c("St", "DSh", "SR", "GSR", "Sh"),
                        start = NULL, etastart = NULL, mustart = NULL,
                        offset = rep(0, nobs), family = gaussian(),
                        control = list(), intercept = TRUE,
                        use_parallel = TRUE)
}
\arguments{
\item{x}{A numeric matrix of predictors. As for \code{\link{glm.fit}}.}

\item{y}{A numeric vector of responses. As for \code{\link{glm.fit}}.}

\item{weights}{An optional vector of weights to be used in the fitting process. As for \code{\link{glm.fit}}.}

\item{model_class}{A character vector specifying the shrinkage model(s) to be used. Allowed values are \code{"St"}, \code{"DSh"}, \code{"SR"}, \code{"GSR"}, and \code{"Sh"}.
If a single value is provided, only that method is run. If multiple values are provided, the function runs the specified methods in parallel and returns the best one based on AIC.
When the user does not explicitly supply a value for \code{model_class}, the default is \code{c("St", "DSh", "SR", "GSR")} (i.e. \code{"Sh"} is not considered).}

\item{start}{Starting values for the parameters. As for \code{\link{glm.fit}}.}

\item{etastart}{Starting values for the linear predictor. As for \code{\link{glm.fit}}.}

\item{mustart}{Starting values for the mean. As for \code{\link{glm.fit}}.}

\item{offset}{An optional offset to be included in the model. As for \code{\link{glm.fit}}.}

\item{family}{A description of the error distribution and link function to be used in the model. As for \code{\link{glm.fit}}.}

\item{control}{A list of parameters for controlling the fitting process. As for \code{\link{glm.fit}}.}

\item{intercept}{A logical value indicating whether an intercept should be included in the model. As for \code{\link{glm.fit}}.}

\item{use_parallel}{Logical. If TRUE, enables parallel execution of the fitting process.
Defaults to TRUE. Set to FALSE for serial execution.}
}
\value{
The value returned by \code{savvy_glm.fit2} has the same structure as the value returned by \code{glm.fit}. It includes the following components:
\item{coefficients}{the estimated coefficients.}
\item{residuals}{the working residuals, that is the residuals in the final iteration of the IWLS fit.}
\item{fitted.values}{the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.}
\item{R}{the upper-triangular factor of the QR decomposition of the weighted model matrix.}
\item{rank}{the numeric rank of the fitted linear model.}
\item{qr}{the QR decomposition of the weighted model matrix.}
\item{family}{the family object used.}
\item{linear.predictors}{the final linear predictors.}
\item{deviance}{the deviance of the final model.}
\item{aic}{the AIC of the final model.}
\item{null.deviance}{the deviance for the null model.}
\item{iter}{the number of iterations used.}
\item{weights}{the final weights used in the fitting process.}
\item{prior.weights}{the weights initially supplied.}
\item{df.residual}{the residual degrees of freedom.}
\item{df.null}{the residual degrees of freedom for the null model.}
\item{y}{the response vector used.}
\item{converged}{a logical value indicating whether the IRLS iterations converged.}
\item{boundary}{a logical value indicating whether the algorithm stopped at a boundary value.}
\item{time}{the time taken for the fitting process.}
\item{chosen_fit}{the name of the chosen fitting method based on AIC.}
}
\description{
\code{savvy_glm.fit2} is a modified version of \code{glm.fit} in the stats package,
incorporating custom optimization functions (\code{St_ost}, \code{DSh_ost}, \code{SR_ost}, \code{GSR_ost}, and \code{Sh_ost}).
The user can specify a preferred shrinkage model via the \code{model_class} argument.
When the user does not explicitly supply a value for \code{model_class}, the function defaults to running only \code{"St"}, \code{"DSh"}, \code{"SR"}, and \code{"GSR"}.
If the user explicitly includes \code{"Sh"} (e.g. \code{model_class = c("St", "DSh", "SR", "GSR", "Sh")}), then \code{Sh_ost} is also evaluated.
}
\details{
\code{savvy_glm.fit2} extends \code{glm.fit} by using custom optimization functions to improve the convergence properties of the iteratively reweighted least squares (IRLS) algorithm.
The user may choose to run a specific shrinkage method by supplying a single value to the \code{model_class} argument.
If multiple values are provided (or if the default is used), the function evaluates a set of custom optimization methods and selects the final model based on the Akaike Information Criterion (AIC).
By default, the function considers only \code{St_ost}, \code{DSh_ost}, \code{SR_ost}, and \code{GSR_ost} (i.e. \code{model_class = c("St", "DSh", "SR", "GSR")}).
If the user explicitly includes \code{"Sh"} in \code{model_class} (for example, \code{model_class = c("St", "DSh", "SR", "GSR", "Sh")}), then the method \code{Sh_ost} is also evaluated.
The fitting process starts with initial parameter values and iterates through the IRLS algorithm. In each iteration, the coefficients are computed using the specified custom methods.
The method with the lowest AIC is chosen as the final model, ensuring that the model converges to the best solution given the data and the specified family.

\strong{Custom Optimization Methods:}
\describe{
  \item{\strong{Stein Estimator (St)}}{
    \enumerate{
      \item Applies a global multiplicative shrinkage factor to all coefficients.
      \item The factor is chosen to reduce MSE based on the overall signal-to-noise ratio.
      \item Simple and fast; works well when all coefficients can be shrunk similarly.
    }
  }
  \item{\strong{Diagonal Shrinkage (DSh)}}{
    \enumerate{
      \item Extends the St approach by assigning a separate shrinkage factor to each coefficient.
      \item Each factor is computed from the coefficient size and its associated variance.
      \item More flexible than St, especially when coefficients vary in scale or importance.
    }
  }
  \item{\strong{Generalized Slab Regression (GSR)}}{
    \enumerate{
      \item Extends SR by shrinking along multiple directions based on the data.
      \item These directions are usually chosen as leading principal components of the design matrix.
      \item Provides adaptive regularization in settings with collinearity or factor structure.
    }
  }
  \item{\strong{Shrinkage Estimator (Sh)}}{
    \enumerate{
      \item Uses a non-diagonal shrinkage matrix derived from solving a Sylvester equation.
      \item Applies shrinkage by transforming the OLS estimator through a matrix that minimizes the MSE.
      \item Included only when \code{"Sh"} is specified in the \code{model_class} argument.
    }
  }
}
}
\references{
The custom optimization methods used in this function are designed to improve the convergence properties of the GLM fitting process.
Marschner, I.C. (2011) glm2: Fitting generalized linear models with convergence problems. The R Journal, Vol. 3/2, pp.12-15.
}
\seealso{
\code{\link{glm.fit}}, \code{\link{glm}}, \code{\link{glm.fit2}}
}
\author{
Ziwei Chen and Vali Asimit\cr
Maintainer: Ziwei Chen <ziwei.chen.3@citystgeorges.ac.uk>
}
\keyword{models}
\keyword{regression}
